# 第2章 信息的表示和处理

<!-- MarkdownTOC autolink='true' -->

- [2.0 序言](#20-%E5%BA%8F%E8%A8%80)
- [2.1 信息存储](#21-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8)
	- [2.1.1 十六进制表示法](#211-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)
	- [2.1.2 字数据大小](#212-%E5%AD%97%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F)
	- [2.1.3 寻址和字节顺序](#213-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F)
	- [2.1.4 表示字符串](#214-%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)
	- [2.1.5 表示代码](#215-%E8%A1%A8%E7%A4%BA%E4%BB%A3%E7%A0%81)
	- [2.1.6 布尔代数简介](#216-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%AE%80%E4%BB%8B)
	- [2.1.7 C语言中的位级运算\(返回具体值\)](#217-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BA%A7%E8%BF%90%E7%AE%97%E8%BF%94%E5%9B%9E%E5%85%B7%E4%BD%93%E5%80%BC)
	- [2.1.8 C语言中的逻辑运算\(返回0或1\)](#218-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E8%BF%94%E5%9B%9E0%E6%88%961)
	- [2.1.9 C语言中的位移运算](#219-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97)
- [2.2 整数表示](#22-%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA)
	- [2.2.1 整型数据类型](#221-%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
	- [2.2.2 无符号数编码\(B2Uw\)](#222-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%BC%96%E7%A0%81b2uw)
	- [2.2.3 补码编码\(B2Tw\)](#223-%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81b2tw)
	- [2.2.4 有符号数和无符号数之间转换\(U2Tw和T2Uw\)](#224-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2u2tw%E5%92%8Ct2uw)
	- [2.2.5 C语言中的有符号数和无符号数](#225-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0)
	- [2.2.6 位的扩展和截断](#226-%E4%BD%8D%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E6%88%AA%E6%96%AD)
- [2.3 整数运算](#23-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97)
	- [2.3.1 无符号加法](#231-%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8A%A0%E6%B3%95)
	- [2.3.2 补码加法](#232-%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95)
	- [2.3.3 补码的非](#233-%E8%A1%A5%E7%A0%81%E7%9A%84%E9%9D%9E)
	- [2.3.4 无符号乘法](#234-%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95)
	- [2.3.5 补码乘法](#235-%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95)
	- [2.3.6 乘以常数](#236-%E4%B9%98%E4%BB%A5%E5%B8%B8%E6%95%B0)
	- [2.3.7 除以2的幂](#237-%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82)
- [2.4 浮点数](#24-%E6%B5%AE%E7%82%B9%E6%95%B0)
	- [2.4.1 定点表示法](#241-%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95)
	- [2.4.2 浮点表示法\(IEEE 754\)](#242-%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95ieee-754)
	- [2.4.3 数字示例](#243-%E6%95%B0%E5%AD%97%E7%A4%BA%E4%BE%8B)
	- [2.4.4 舍入\(rounding\)](#244-%E8%88%8D%E5%85%A5rounding)
	- [2.4.5 C语言的浮点数](#245-c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0)

<!-- /MarkdownTOC -->


## 2.0 序言
**三种数字表示**
- **无符号（unsigned）** 编码基于传统二进制表示法表示大于或者等于零的数字
- **补码（two's-complement）** 编码表示有符号整数
- **浮点数（floating-point）** 编码表示实数

## 2.1 信息存储
**虚拟内存（Virtual Memory）**：把DRAM、闪存、HDD、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的==字节数组==  
**内存地址（Address）**：一个内存地址指向==一个字节==，所有可能的地址合集组成==虚拟地址空间（Virtual Address Space）==  
**C语言指针**：指针包括==值==和==类型==，值表示某个对象的位置，类型表示该对象的类型  

```
T *p; //p是一个指针变量，指向一个类型为T的对象
```
### 2.1.1 十六进制表示法
**十六进制（Hexadecimal）**：一个字节值域00~FF  
- 二进制（Binary）表示法太冗长  
- 十进制（Decimal）表示法与位模式转换麻烦

C语言十六进制表示：0xFA1D37B  

**Hex ⇄ Bin 进制转换：**  
0000 - 0，0001 - 1，0010 - 2，0011 - 3  
0100 - 4，0101 - 5，0110 - 6，0111 - 7  
1000 - 8，1001 - 9，1010 - A，1011 - B  
1100 - C，1101 - D，1110 - E，1111 - F  
**快速转换：** 当x是2的非负整数n次幂时：x = n^2^  
把n表示成：n = i + 4j  
十六进制表示成：0x(2^i^)(j个0)  
例：n = 11 = 3 + 4 * 2 ：0x2^3^(2个0) = 0x800  

**Hex ⇄ Dec 进制转换：**  
**Dec to Hex**：x = q * 16 + r
314156 = 19634 * 16 + **12（C）**  
19634 = 1227 * 16 + **2（2）**  
1227 = 76 * 16 + **11（B）**  
76 = 4 * 16 + **12（C）**  
4 = 0 * 16 + **4（4）**  
十六进制：**0x4CB2C**  
**Hex to Dec**: 0x7AF = **7 x 16^2^** + **10 x 16^1^** + **15 x 16^0^**

### 2.1.2 字数据大小
**字长（Word Size）**：表示指针数据标称（nominal size）大小，决定了==虚拟地址空间==的最大值  
- 32位寻址空间最大：4GB  
- 64位寻址空间最大：16EB  

**C语言数据类型：**  
- char：1 byte  
- short：2 bytes  
- int：4 bytes  
- long：4 bytes（32位），8 bytes（64位）

### 2.1.3 寻址和字节顺序
**对象地址**：所使用字节重==最小==的地址（下例中的0x100）  
32 bit int类型数据：0x01234567（高位字节0x01，低位字节0x67）  
大端法：0x100存放0x01，0x101存放0x23，0x102存放0x45，0x103存放0x67  
小端法：0x100存放0x67，0x101存放0x45，0x102存放0x23，0x103存放0x01  

### 2.1.4 表示字符串
**C语言中字符串：** 被编码为一个以null（其值为0）字符结尾的==字符数组==  
**标准编码表示字符：**  
- [ASCII](http://www.asciitable.com/)：1个字符1个字节，适合英语文档  
- Unicode：1个字符4个字节，支持更多语言  
- UTF-8：1个字符1个字节  

### 2.1.5 表示代码
```
int sum(int x, int y) {
    return x + y;
}
不同机器上编译后的机器代码：
Linux 32    55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows     55 89 e5 8b 45 0c 03 45 08 5d c3
Sun         81 c3 e0 08 90 02 00 09
Linux 64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
```
不同机器类型使用==不同且不兼容==的指令和编码方式

### 2.1.6 布尔代数简介
True 1, False 0  

**布尔运算**：
- 非（NOT）：~
- 与（AND）：&
- 或（OR）：|
- 异或（EXCLUSIVE-OR）：^

### 2.1.7 C语言中的位级运算(返回具体值)
**位级运算**：按位进行==布尔运算==  
C 表达式 | 二进制表达式 | 二进制结果 | 十六进制结果
---|---|---|---
~0x41 | \~[0100 0001] | [1011 1110] | 0xBE
0x69&0x55 | [0110 1001]&[0101 0101] | [0100 0001] | 0x41
0x69\|0x55 | [0110 1001]\|[0101 0101] | [0111 1101] | 0x7D

### 2.1.8 C语言中的逻辑运算(返回0或1)
**逻辑运算**：||，&&，！ 

逻辑运算与位级运算区别：
- 区别一：返回1或者0，表示结果为TRUE或者FALSE
- 区别二：如果第一个参数求值确定表达式结果则不对第二个参数求值

### 2.1.9 C语言中的位移运算

操作 | 值
---|---
参数x | [01100011] [10010101]
x << 4 | [0011==0000==] [0101==0000==]
x >> 4（逻辑右移） | [==0000==0110] [==0000==1001]
x >> 4（算术右移） | [==0000==0110] [==1111==1001]
**有符号数**：两种右移都可以，默认算术右移  
**无符号数**：必须逻辑右移

## 2.2 整数表示
整数的数据与算数操作术语

符号 | 类型 | 含义 | 符号 | 类型 | 含义 | 符号 | 类型 | 含义
---|---|---|---|---|---|---|---|---
*B2T~w~* | 函数 | 二进制转补码 | *+^t^~w~* | 操作 | 补码加法 | *TMin~w~* | 常数 | 最小补码值
*B2U~w~* | 函数 | 二进制转无符号数 | *+^u^~w~* | 操作 | 无符号数加法 | *TMax~w~* | 常数 | 最大补码值
*U2B~w~* | 函数 | 无符号数转二进制 | **^t^~w~* | 操作 | 补码乘法 | *UMax~w~* | 常数 | 最大无符号数
*U2T~w~* | 函数 | 无符号数转补码 | **^u^~w~* | 操作 | 无符号数乘法 |
*T2U~w~* | 函数 | 补码转无符号数 | *-^u^~w~* | 操作 | 无符号数取反 |

### 2.2.1 整型数据类型
32位程序上C语言整型数据类型取值范围

C数据类型 | 最小值 | 最大值
---|---|---
[signed]char | -128 | 127
unsigned char | 0 | 255
short | -32768 | 32767
unsigned short| 0 | 65535
int | -2147483648 | 2147483647
unsigned | 0 | 4294967295
long | -2147483648 | 2147483647
unsigned long| 0 | 4294967295
int32_t | -2147483648 | 2147483647
uint32_t | 0 | 4294967295
int64_t | -9233372036854775808 | 9233372036854775807
uint64_t | 0 | 18446744073709551615

> C和C++都支持有符号（默认）和无符号数  
> Java 只支持有符号数

### 2.2.2 无符号数编码(B2Uw)
***B2U*~w~（Binary to Unsigned）** 函数：表示二进制转无符号数
```math
B2U_w(\vec{x}) = \sum_{i=0}^{w-1}x_i2^i
```
*B2U*~4~([0001]) = 0 * 2^3^ + 0 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ = 0 + 0 + 0 + 1 = 1  
*B2U*~4~([0101]) = 0 * 2^3^ + 1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ = 0 + 4 + 0 + 1 = 5  
*B2U*~4~([1011]) = 1 * 2^3^ + 0 * 2^2^ + 1 * 2^1^ + 1 * 2^0^ = 8 + 0 + 2 + 1 = 11  
*B2U*~4~([1111]) = 1 * 2^3^ + 1 * 2^2^ + 1 * 2^1^ + 1 * 2^0^ = 8 + 4 + 2 + 1 = 15  

***UMax**~w~* 最大值：表示w位二进制能表示无符号数的最大值
```math
UMax_w = \sum_{i=0}^{w-1}2^w-1
```
w = 4时：UMax~4~ = B2U~4~([1111]) = 2^4^ - 1 = 15

**无符号数编码的唯一性**：每一个介于0~2^w^-1之间的数都有唯一一个w位的值编码

### 2.2.3 补码编码(B2Tw)
***B2T*~w~（Binary to Two's-complement）** 函数：表示二进制转补码
```math
B2T_w(\vec{x}) = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
```
*B2T*~4~([0001]) = -0 * 2^3^ + 0 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ = 0 + 0 + 0 + 1 = 1  
*B2T*~4~([0101]) = -0 * 2^3^ + 1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ = 0 + 4 + 0 + 1 = 5  
*B2T*~4~([1011]) = -1 * 2^3^ + 0 * 2^2^ + 1 * 2^1^ + 1 * 2^0^ = -8 + 0 + 2 + 1 = -5  
*B2T*~4~([1111]) = -1 * 2^3^ + 1 * 2^2^ + 1 * 2^1^ + 1 * 2^0^ = -8 + 4 + 2 + 1 = -1  

***TMax**~w~* 最大值：表示w位二进制能表示补码的最大值  
向位量[01...1]（清除负权位，设置其他所有位）
```math
TMax_w = \sum_{i=0}^{w-2}2^i = 2^{w-1}-1
```
***TMin**~w~* 最小值：表示w位二进制能表示补码的最小值  
向位量[10...0]（设置负权位，清除其他所有位）
```math
TMin_w = -2^{w-1}-1
```
**补码编码也具有唯一性**

**有符号数的其他表示方法**
- 反码（Ones' Complement）：除了最高有效位的权是-(2^w-1^-1)而不是-2^w-1^，其他和补码一样
```math
B2O_w(\vec{x}) = -x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i
```
- 原码（Sign-Magnitude）：最高有效位是符号位，用来确定剩下的位应该取负权还是正权

### 2.2.4 有符号数和无符号数之间转换(U2Tw和T2Uw)
C语言支持不同数字数据类型之间进行==强制转换==
```
int x;
unsigned u;
(unsigned)x //把x转换成无符号数值
(int)u      //把u转换成有符号整数
```
==强制类型转换：保持位值不变，只改变解释这些位的方式==

```
short int v = -12345;
unsigned short uv = (unsigned short)v;
//v = -12345    uv = 53191  
//-12345的16位补码和53191的16位无符号二进制表示一样
```
```
unsigned u = 4294967295u;   //UMax
int tu = (int)u;
//u = 4294967295    tu-1
//32位的UMax和-1的补码二进制表示一样
```
**无符号数转补码：*T2U*~w~**  
**原理**：当*TMin~w~*≤ x ≤*TMax~w~* 时  
***T2U~w~(x)*** = *B2U~w~(T2B~w~(x))* =：
- x + 2^w^，x < 0
- x，x ≥ 0

例：
- *T2U~16~*(-12345) = -123456 + 2^16^ = 53191
- *T2U~w~*(-1) = -1 + 2^w^ = *UMax~w~*

**补码转无符号数：*U2T*~w~**  
**原理**：当0≤ u ≤*UMax~w~* 时  
***U2T~w~(u)*** = *B2T~w~(U2B~w~(u))* =：
- u，u ≤ *TMax~w~*
- u - 2^w^，u > *TMax~w~*

### 2.2.5 C语言中的有符号数和无符号数
声明无符号常量时需要加后缀“U”或者“u”：123456U

**强制类型转换**
```
int tx, ty;
unsigned ux, uy;
tx = (int) ux;
uy = (unsigned) ty;
```
**隐式转换**
```
int tx, ty;
unsigned ux, uy;
tx = ux; /* Cast to signed */
uy = ty; /* Cast to unsigned */
```
printf输出数值时：
- %d：有符号十进制
- %u：无符号十进制
- %x：十六进制

执行运算时，如果**一个运算数有符号**而**另一个运算数无符号**，==C会隐式地把有符号参数强制类型转换为无符号数==

表达式 | 类型 | 求值
---|---|---
0 == 0U | 无符号 | 1
-1 < 0 | 有符号 | 1
-1 < 0U | 无符号 | 0

**无符号数作用**：

### 2.2.6 位的扩展和截断
**无符号数的零扩展（zero extension）**：通过==补0==来扩展位数  
**补码数的符号扩展（sign extension）**：通过==补符号位==来扩展位数
```
short sx = -12345;      //-12345：cf c7
unsigned short usx = sx;// 53191：cf c7
int x = sx;             //-12345：ff ff cf c7
unsigned ux = usx;      // 53191：00 00 cf c7
```
**截断无符号数**：x位截断k位成为x'：x' = x mod 2^k^  
**截断补码数值**：x位截断k位成为x'：x' = *U2T*~k~(x mod 2^k^)

## 2.3 整数运算
### 2.3.1 无符号加法

**(+^u^~w~)**：把整数x+y截断为w位得到的结果，并且把这个结果当成无符号数

0≤x, y<2^w^时：

x+^u^~w~y = x + y, x + y < 2^w^（正常）  
x+^u^~w~y = x + y - 2^w^, 2^w^≤ x + y < 2^w+1^（溢出）

**(\-^u^~w~)**：无符号数求反

-^u^~w~x = x, x = 0  
-^u^~w~x = 2^w^-x, x > 0

### 2.3.2 补码加法

**(+^t^~w~)**：把整数x+y截断为w位的结果，并且把这个结果当成补码

-2^w-1^≤x, y≤ 2^w-1^-1时：

x+^t^~w~y = x + y - 2^w^, 2^w-1^≤x + y  
x+^t^~w~y = x + y, -2^w-1^≤x + y\< 2^w-1^  
x+^t^~w~y = x + y + w^w^, x + y < -2^w-1^


### 2.3.3 补码的非

TMin~w~≤ x ≤TMax~w~时：

-^t^~w~x = TMin~w~, x = TMin~w~  
-^t^~w~x = -x, x > Tmin~w~

### 2.3.4 无符号乘法

0≤x, y≤UMax~w~：

x*^u^~w~y = (x * y)mod 2^w^

### 2.3.5 补码乘法

TMin~w~≤x, y≤TMax~w~：

x*^t^~w~y = U2T~w~((x * y)mod 2^w^)

### 2.3.6 乘以常数

乘法指令需要10个或者更多时钟周期，i7 Haswell也需要3个时钟周期。因此编译器尝试用**位移和加法运算的组合**来代替常数因子乘法

**与2的幂相乘的无符号乘法：**

无符号x，无符号k（0 ≤ k < 0）

x << k = x*^u^~w~2^k^

**与2的幂相乘的补码乘法：**

补码值x，无符号k（0 ≤ k < 0）

x << k = x*^t^~w~2^k^

### 2.3.7 除以2的幂

**除以2的幂的无符号除法**

无符号x，无符号k（0 ≤ k < 0）

x >> k = ⌊x/2^k^⌋

**除以2的幂的补码除法，向下舍入**

补码值x，无符号k（0 ≤ k < 0）

x >> k = ⌊x/2^k^⌋

**除以2的幂的补码除法，向上舍入**

补码值x，无符号k（0 ≤ k < 0）

x >> k = ⌈x/2^k^⌉

## 2.4 浮点数

### 2.4.1 定点表示法

**十进制小数表示**：d~m~d~m-1~……d~1~d~0~.d~-1~d~-2~……d~-n~

12.34~10~ = 1 x 10^1^ + 2 x 10^0^ + 3 x 10^-1^ + 4 x 10^-2^

**二进制小数表示**：b~m~b~m-1~……b~1~b~0~.b~-1~b~-2~……b~-n~

101.11~2~ = 1 x 2^2^ + 0 x 2^1^ + 1 x 2^0^ + 1 x 2^-1^ + 1 x 2^-2^

小数点左移：相当于除以2  
小数点右移：相当于乘以2

### 2.4.2 浮点表示法(IEEE 754)

IEEE 754 标准表示浮点数：V = (-1)^s^ x M x 2^E^

- s 符号（sign）决定正(s=0)负(s=1)
- M 尾数（significand）是二进制小数
- E 阶码（exponent）对浮点数加权

浮点数位表示划分为三个字段

- 1位符号位，编码符号s
- k位阶码字段，编码阶码E（exp=e~k-1~...e~1~e~0~）
- n位小数字段，编码尾数M（frac=f~n-1~...f~1~f~0~）

单精度(32-bit)：s(1-bit) exp(8-bit) frac(23-bit)  
双精度(64-bit)：s(1-bit) exp(11-bit) frac(52-bit)

**情况一：规格化的值**

阶码值 E = e - Bias
> e是无符号数，表示阶码e~k-1~...e~1~e~0~  
> Bias = 2^k-1^ - 1，单精度127，双精度1023

尾数值 M = 1 + f
> f是原值的小数部分  
> 0≤ f <1, 1≤ M <2

**情况二：非规格化的值**

阶码e为全0时，所表示的数是非规格化形式，表示0

阶码值 E = 1 - Bias

尾数值 M = f

**情况三：特殊值**

阶码e全为1时，小数部分f全为0时，表示无穷
- 单精度正无穷：s(0)exp(11111111)frac(00000000000000000000000)
- 单精度负无穷：s(1)exp(11111111)frac(00000000000000000000000)

**定点表示法编码成浮点表示法：求s，求f，求e**  
```
//格式化
float F = 15213.0 = 11101101101101 = 1.1101101101101 x 2^13  
//求f
M = 1.1101101101101  
f = 1101101101101  
//求e
E = 13, Bias = 127  
e = 140 = 10001100  
//求s
s = 0
//结果
s(0)exp(10001100)frac(11011011011010000000000)
```
**浮点表示法解码成定点表示法：求E，求M，求V**
```
//格式化
float: 0xC0A00000
Binary: 1100 0000 1010 0000 0000 0000 0000 0000
s(1)exp(10000001)frac(01000000000000000000000)
//求E
E = e - Bias = 129 - 127 = 2
//求M
M = 1 + f = 1.01000000000000000000000 = 1 + 1/4 = 1.25
//求V
V = (-1)^s x M x 2^E = (-1)^1 x 1.25 x 2^2 = -5
```
### 2.4.3 数字示例

描述 | exp | frac | 单精度 | 双精度
---|---|---|---|---
0 | 00...00 | 0...00 | 0.0 | 0.0
最小非规格化数 | 00...00 | 0...01 | 1.4 x 10^-45^ | 4.9 x 10^-324^
最大非规格化数 | 00...00 | 1...11 | 1.2 x 10^-38^ | 2.2 x 10^-308^
最小规格化数 | 00...01 | 0...00 | 1.2 x10^-38^ | 2.2 x 10^-308^
1 | 01...11 | 0...00 | 1.0 | 1.0
最大规格化数 | 11...10 | 1...11 | 3.4 x 10^38^ | 1.8 x 10^308^

### 2.4.4 舍入(rounding)

**向偶数舍入（round-to-even）**：找到一个最近的匹配值，如果是中间数，则将向上或者向下舍入
使得结果**最低有效数字是偶数**

**向零舍入（round-to-zero）**：把正数向下舍入，把负数向上舍入


方式 | 1.40 | 1.60 | 1.50 | 2.50 | -1.50
---|---|---|---|---|---
向偶数舍入 | 1 | 2 | 2 | 2 | -2
向零舍入 | 1 | 1 | 1 | 2 | -1
向下舍入 | 1 | 1 | 1 | 2 | -2
向上舍入 | 2 | 2 | 2 | 3 | -1

**二进制小数舍入至最近的四分之一（二进制小数点右边2位）**

10.00011~2~ 向下舍入 10.00~2~  
10.00110~2~ 向上舍入 10.01~2~  
10.11100~2~ 向上舍入 11.00~2~  
10.10100~2~ 向下舍入 10.10~2~

### 2.4.5 C语言的浮点数

C语言支持两种不同的浮点数据类型：float和double

float，double 和int强制转换原则
- 从 int 转换成 float，数字不会溢出，但是可能被舍入
- 从 int 或 float 转换成 double，更精确
- 从 double 转换成 float 可能溢出，舍入或者正负无穷
- 从 float 或 double 转换成int，会向零舍入